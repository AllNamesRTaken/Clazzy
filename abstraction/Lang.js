// Generated by CoffeeScript 1.8.0
(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define(["underscore/main"], function(_) {
    'use strict';
    var Lang, _toArray;
    _toArray = function(obj, offset, startWith) {
      return (startWith || []).concat(Array.prototype.slice.call(obj, offset || 0));
    };
    return Lang = {
      hitch: function(that, func) {
        var pre;
        if (arguments.length > 2) {
          pre = _toArray(arguments, 2);
          return function() {
            var args, e;
            args = _toArray(arguments);
            try {
              return func.apply(this, pre.concat(args));
            } catch (_error) {
              e = _error;
              e.func = func;
              throw e;
            }
          };
        }
        if (!that) {
          return func;
        }
        if (typeof func === "string") {
          func = that[func];
        }
        return function() {
          var e;
          try {
            return func.apply(that, arguments || []);
          } catch (_error) {
            e = _error;
            e.func = e.func || func;
            throw e;
          }
        };
      },
      partial: function(method) {
        var arr;
        arr = [null];
        return this.hitch.apply(this, arr.concat(_toArray(arguments)));
      },
      clone: function(src) {
        var item, r;
        if (!src || typeof src !== "object" || "function" === typeof src) {
          return src;
        }
        if (src.nodeType && __indexOf.call(src, "cloneNode") >= 0) {
          return src.cloneNode(true);
        }
        if (src instanceof Date) {
          return new Date(src.getTime());
        }
        if (src instanceof RegExp) {
          return new RegExp(src);
        }
        if (Lang.isArray(src)) {
          r = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = src.length; _i < _len; _i++) {
              item = src[_i];
              _results.push(Lang.clone(item));
            }
            return _results;
          })();
        } else {
          r = src.constructor ? new src.constructor() : {};
        }
        return Lang.mixin(r, src, Lang.clone);
      },
      isArray: function(it) {
        return it && (it instanceof Array || typeof it === "array");
      },
      isElement: function(target) {
        if ((target != null ? target.nodeType : void 0) === 1) {
          return true;
        } else {
          return false;
        }
      },
      isFunction: function(it) {
        return Object.prototype.toString.call(it) === "[object Function]";
      },
      mixin: function(dest, source, initValues, copyFunc) {
        var empty, name, s;
        if (dest == null) {
          dest = {};
        }
        if (initValues == null) {
          initValues = {};
        }
        for (name in source) {
          empty = {};
          s = source[name];
          if (!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))) {
            dest[name] = copyFunc ? copyFunc(s) : initValues[name] || s;
          }
        }

        /* dont know what this is, removed for now
        if has("bug-for-in-skips-shadowed")
            if source
                for (i = 0; i < _extraLen; ++i) 
                    name = _extraNames[i]
                    s = source[name]
                    if (not(name of dest) or (dest[name] isnt s and (not(name of empty) or empty[name] isnt s)))
                        dest[name] = if copyFunc then copyFunc(s) else s
         */
        return dest;
      },
      toArray: _toArray,
      debounce: _.debounce,
      throttle: _.throttle,
      indexOf: _.indexOf,
      filter: _.filter,
      map: _.map,
      isRegExp: _.isRegExp
    };
  });

}).call(this);

//# sourceMappingURL=Lang.js.map
