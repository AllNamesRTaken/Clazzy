// Generated by CoffeeScript 1.8.0
(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  define(["clazzy/abstraction/Lang", "clazzy/Exception"], function(lang, Exception) {
    var BaseClass;
    BaseClass = (function() {
      BaseClass.prototype.declaredClass = "BaseClass";

      BaseClass.prototype._implements = function() {
        return [];
      };

      BaseClass.prototype._fullname = function() {
        return ["BaseClass"];
      };

      function BaseClass() {
        'use strict';
        var key, prop, _ref;
        if (arguments.length && "object" === typeof arguments[0]) {
          _ref = arguments[0];
          for (key in _ref) {
            prop = _ref[key];
            this[key] = prop;
          }
        }
        this._locked = {};
        this.initConverters();
        this.initWatchers();
        this.initValidators();
        this.initConnections();
        this._model = {};
        return this;
      }

      BaseClass.prototype.initConverters = function() {
        return this._converters = function(prop, value, oldValue) {
          var callback, callbacks, cval, e, key, _i, _len, _ref;
          if (callbacks = (_ref = this._converters[key = '_' + prop]) != null ? _ref.slice() : void 0) {
            for (_i = 0, _len = callbacks.length; _i < _len; _i++) {
              callback = callbacks[_i];
              if (callback.call == null) {
                (new Exception("NotAFunctionException", "converter is not a function for property: " + prop)).Throw();
                return value;
              }
              try {
                cval = callback.call(this, value, oldValue);
              } catch (_error) {
                e = _error;
                console.log(e);
                (new Exception("ConverterException", "Converter function threw exception for " + this.declaredClass + " and value=" + value)).Throw();
              }
              return cval;
            }
          }
          return value;
        };
      };

      BaseClass.prototype.initWatchers = function() {
        return this._watchers = function(prop, oldValue, newValue, index, self) {
          var callback, callbacks, e, key, _i, _j, _len, _len1, _ref;
          if (callbacks = (_ref = this._watchers[key = '_' + prop]) != null ? _ref.slice() : void 0) {
            for (_i = 0, _len = callbacks.length; _i < _len; _i++) {
              callback = callbacks[_i];
              if (callback.call == null) {
                (new Exception("NotAFunctionException", "watcher is not a function for property: " + prop)).Throw();
                return this;
              }
              try {
                callback.call(this, prop, oldValue, newValue, index, self);
              } catch (_error) {
                e = _error;
                console.log(e);
                (new Exception("WatcherException", "Watcher function threw exception for " + this.declaredClass + " and newValue=" + newValue)).Throw();
              }
            }
          }
          if (callbacks = this._watchers['*']) {
            for (_j = 0, _len1 = callbacks.length; _j < _len1; _j++) {
              callback = callbacks[_j];
              if (callback.call == null) {
                (new Exception("NotAFunctionException", "watcher is not a function for property: " + prop)).Throw();
                return this;
              }
              try {
                callback.call(this, prop, oldValue, newValue, index, self);
              } catch (_error) {
                e = _error;
                console.log(e);
                (new Exception("WatcherException", "Watcher function threw exception for " + this.declaredClass + " and newValue=" + newValue)).Throw();
              }
            }
          }
          return this;
        };
      };

      BaseClass.prototype.initValidators = function() {
        return this._validators = function(prop, oldValue, newValue, index, self, hint) {
          var callback, callbacks, e, invalid, key, _i, _len, _ref;
          if (callbacks = (_ref = this._validators[key = '_' + prop]) != null ? _ref.slice() : void 0) {
            for (_i = 0, _len = callbacks.length; _i < _len; _i++) {
              callback = callbacks[_i];
              if (callback.call == null) {
                (new Exception("NotAFunctionException", "validator is not a function for property: " + prop)).Throw();
                return 1;
              }
              try {
                invalid = this.set("_invalidated", callback.call(this, prop, oldValue, newValue, index, self, hint), prop, self);
              } catch (_error) {
                e = _error;
                console.log(e);
                (new Exception("ValidatorException", "Validator function threw exception for " + this.declaredClass + " and newValue=" + newValue)).Throw();
              }
              if (invalid) {
                console.warn("Failed validation for property '" + prop + "' on " + this.declaredClass + " with value ", newValue);
                return invalid;
              }
            }
          }
          return 0;
        };
      };

      BaseClass.prototype.initConnections = function() {
        this._invalidated = {};
        return this._connections = function(prop, value, index, self) {
          var connection, connections, e, invalid, key, _i, _len, _ref;
          if (connections = (_ref = this._connections[key = '_' + prop]) != null ? _ref.slice() : void 0) {
            for (_i = 0, _len = connections.length; _i < _len; _i++) {
              connection = connections[_i];
              if (!connection) {
                (new Exception("NotAFunctionException", "connection is not a defined for property: " + prop)).Throw();
                return 1;
              }
              try {
                if (self !== connection.target) {
                  connection.target.set(connection.prop, value, index, this);
                }
              } catch (_error) {
                e = _error;
                console.log(e);
                (new Exception("ConnectException", "Connected setter threw exception for " + this.declaredClass + " connected to " + this.connection.target.declaredClass)).Throw();
              }
              invalid = connection.target["_invalidated"][connection.prop] || 0;
              if (invalid) {
                return invalid;
              }
            }
          }
          return 0;
        };
      };

      BaseClass.prototype.is = function(name) {
        'use strict';
        if ("object" === typeof name && (name != null ? name.declaredClass : void 0)) {
          name = name.declaredClass;
        }
        if (lang.isFunction(name)) {
          name = name.classname;
        }
        if (__indexOf.call(this._fullname(), name) >= 0) {
          return true;
        }
        if (__indexOf.call(this._implements(), name) >= 0) {
          return true;
        }
        return false;
      };

      BaseClass.prototype.isnt = function(name) {
        'use strict';
        return !this.is(name);
      };

      BaseClass.prototype.haz = function(prop) {
        'use strict';
        var _ref;
        if (((_ref = this._model) != null ? _ref.hasOwnProperty(prop) : void 0) || this[prop] !== void 0) {
          return true;
        }
        return false;
      };

      BaseClass.prototype.haznt = function(prop) {
        'use strict';
        return !this.haz(prop);
      };

      BaseClass.prototype.addModel = function(model) {
        if (model == null) {
          model = {};
        }
        lang.mixin(this._model, model);
        if (this.__init != null) {
          return lang.mixin(this._model, this.__init);
        }
      };

      BaseClass.prototype.set = function(prop, value, index, self, dontTrigger) {
        var cancel, hasValidator, hint, key, model, newValue, oldValue, _ref, _ref1;
        if (dontTrigger == null) {
          dontTrigger = false;
        }
        'use strict';
        model = ((_ref = this._model) != null ? _ref[prop] : void 0) !== void 0 ? this._model : this;
        if (this.haznt(prop)) {
          (new Exception("IllegalPropertyNameException", "No property " + prop + " on class " + this.declaredClass)).Throw();
          return void 0;
        }
        oldValue = model[prop];
        newValue = this._converters(prop, value, oldValue);
        if (newValue === oldValue) {
          return newValue;
        }
        if (1 === (cancel = this._validators(prop, oldValue, newValue, index, self))) {
          return oldValue;
        }
        hint = this._connections(prop, newValue, index, self, dontTrigger);
        if (hint) {
          if (!(hasValidator = ((_ref1 = this._validators[key = '_' + prop]) != null ? _ref1.length : void 0) > 0)) {
            newValue = oldValue;
          } else {
            if (1 === (cancel = this._validators(prop, oldValue, newValue, index, self, hint))) {
              return oldValue;
            }
          }
        }
        if (index != null) {
          model[prop][index] = newValue;
        } else {
          model[prop] = newValue;
        }
        if (!dontTrigger) {
          this._watchers(prop, oldValue, newValue, index, self);
        }
        return newValue;
      };

      BaseClass.prototype.get = function(prop) {
        'use strict';
        var model, _ref;
        model = ((_ref = this._model) != null ? _ref[prop] : void 0) !== void 0 ? this._model : this;
        if (this.haznt(prop)) {
          (new Exception("IllegalPropertyNameException", "No property " + prop + " on class " + this.declaredClass)).Throw();
          return void 0;
        }
        return model[prop];
      };

      BaseClass.prototype.trigger = function(prop) {
        var model, val, _ref;
        model = ((_ref = this._model) != null ? _ref[prop] : void 0) !== void 0 ? this._model : this;
        if (this.haznt(prop)) {
          (new Exception("IllegalPropertyNameException", "No property " + prop + " on class " + this.declaredClass)).Throw();
          return void 0;
        }
        val = model[prop];
        this._connections(prop, val);
        this._watchers(prop, val, val);
        return void 0;
      };

      BaseClass.prototype.convert = function(prop, callback) {
        'use strict';
        var callbacks, key;
        key = prop !== '*' ? '_' + prop : prop;
        callbacks = this._converters[key];
        if (typeof callbacks !== "object") {
          callbacks = this._converters[key] = [];
        }
        callbacks.push(callback);
        return {
          remove: function() {
            return callbacks.splice(lang.indexOf(callbacks, callback), 1);
          }
        };
      };

      BaseClass.prototype.watch = function(prop, callback, debounce) {
        'use strict';
        var callbacks, cb, key;
        key = prop !== '*' ? '_' + prop : prop;
        callbacks = this._watchers[key];
        if (typeof callbacks !== "object") {
          callbacks = this._watchers[key] = [];
        }
        cb = debounce ? lang.debounce(callback, debounce) : callback;
        callbacks.push(cb);
        return {
          remove: function() {
            return callbacks.splice(lang.indexOf(callbacks, cb), 1);
          }
        };
      };

      BaseClass.prototype.validate = function(prop, callback, _first) {
        'use strict';
        var callbacks, key;
        key = '_' + prop;
        callbacks = this._validators[key];
        if (typeof callbacks !== "object") {
          callbacks = this._validators[key] = [];
        }
        if (_first) {
          callbacks.splice(0, 0, callback);
        } else {
          callbacks.push(callback);
        }
        return {
          remove: function() {
            return callbacks.splice(lang.indexOf(callbacks, callback), 1);
          }
        };
      };

      BaseClass.prototype.connect = function(prop, target, targetProp) {
        'use strict';
        var connection, connections, key;
        key = '_' + prop;
        connections = this._connections[key];
        if (typeof connections !== "object") {
          connections = this._connections[key] = [];
        }
        connections.push((connection = {
          target: target,
          prop: targetProp
        }));
        return {
          remove: function() {
            return connections.splice(lang.indexOf(connections, connection), 1);
          }
        };
      };

      BaseClass.prototype.addValidator = function(prop, validator) {
        if (lang.isFunction(validator)) {
          this.validate(prop, validator);
        } else if (lang.isRegExp(validator)) {
          this.validate(prop, lang.partial(function(v, prop, o, n, i, self) {
            if (v.exec(n)) {
              return 0;
            } else {
              return 1;
            }
          }, validator));
        }
        return void 0;
      };

      BaseClass.prototype.inherited = function(caller, args) {
        var classname, ctx, fname, max, passed;
        caller = caller || this.inherited.caller;
        fname = caller.nom;
        args = args || caller["arguments"];
        classname = caller.cls;
        passed = this.declaredClass === classname;
        ctx = this.__super__;
        max = 20;
        while (!((ctx == null) || ((ctx[fname] != null) && (passed = passed || classname === ctx.declaredClass) && classname !== ctx.declaredClass))) {
          ctx = ctx.__super__;
        }
        if (ctx == null) {
          (new Exception("NullPointerException", classname + " has no __super__ with function " + fname)).Throw();
          return void 0;
        }
        if (ctx != null) {
          return ctx[fname].apply(this, args);
        }
      };

      BaseClass.prototype.lock = function(props, deferred) {
        'use strict';
        var invalidateFn, prop, _first, _i, _len;
        if (!lang.isArray(props)) {
          props = [props];
        }
        invalidateFn = function(prop, oldValue, newValue) {
          console.warn("Trying to set locked property '" + prop + "' on " + this.declaredClass);
          return 1;
        };
        for (_i = 0, _len = props.length; _i < _len; _i++) {
          prop = props[_i];
          if (!this.islocked(prop) && (((deferred != null) && !deferred.finished) || (deferred == null))) {
            if (deferred != null) {
              deferred.addBoth(this.ido(this.unlock, prop));
            }
            this._locked[prop] = this.validate(prop, invalidateFn, _first = true);
            if (this["_" + prop + "_locked"] == null) {
              this["_" + prop + "_locked"] = false;
            }
            this.set("_" + prop + "_locked", true);
          }
        }
        return void 0;
      };

      BaseClass.prototype.unlock = function(props) {
        'use strict';
        var prop, _i, _len, _results;
        if (!lang.isArray(props)) {
          props = [props];
        }
        _results = [];
        for (_i = 0, _len = props.length; _i < _len; _i++) {
          prop = props[_i];
          if (this.islocked(prop)) {
            this._locked[prop].remove();
            delete this._locked[prop];
            if (this["_" + prop + "_locked"] != null) {
              _results.push(this.set("_" + prop + "_locked", false));
            } else {
              _results.push(void 0);
            }
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };

      BaseClass.prototype.islocked = function(prop) {
        'use strict';
        return !!((this._locked[prop] != null) === true);
      };

      BaseClass.prototype.toString = function() {
        'use strict';
        return this.declaredClass.substr(this.declaredClass.indexOf(".") + 1);
      };

      BaseClass.prototype.ido = function() {
        var args, f, fn;
        fn = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        if (fn == null) {
          (new Exception("IllegalArgumentsException", "function fn passed to ido() was null or undefined, caller was: " + this.ido.caller.cls + "." + this.ido.caller.nom + "()")).Throw();
          return void 0;
        }
        f = fn;
        if (args.length > 0) {
          f = lang.partial.apply(lang, [fn].concat(args));
        }
        return lang.hitch(this, f);
      };

      return BaseClass;

    })();
    BaseClass.classname = "BaseClass";
    return BaseClass;
  });

}).call(this);

//# sourceMappingURL=BaseClass.js.map
