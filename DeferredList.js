// Generated by CoffeeScript 1.8.0

/*
This is shamelessly taken from the dojo project (v1.7.x) and just rewritten in coffeescript
All credit goes to the dojo team!
 */

(function() {
  define(["clazzy/Clazzy", "clazzy/Deferred"], function(Class, _deferred) {
    return Class("clazzy.DeferredList", _deferred, null, {
      constructor: function() {
        var caller, err, _ref, _ref1;
        try {
          caller = (_ref = this.constructor.caller) != null ? (_ref1 = _ref.caller) != null ? _ref1.caller : void 0 : void 0;
          if (!(caller != null ? caller.nom : void 0)) {
            caller = caller.caller;
          }
          this.fname = (caller != null ? caller.nom : void 0) || "unknown";
          this.cls = (caller != null ? caller.cls : void 0) || "unknown";
        } catch (_error) {
          err = _error;
          console.warn("strict mode used in a function calling DeferredList");
        }
        return this;
      },
      run: function(list, fireOnOneCallback, fireOnOneErrback, consumeErrors, canceller) {
        var addResult, deferredsFinished, i, item, resultList, self, thenFunc, _i, _len;
        if (consumeErrors == null) {
          consumeErrors = true;
        }
        'use strict';
        resultList = [];
        self = this;
        if (list.length === 0 && !fireOnOneCallback) {
          this.resolve([0, []]);
        }
        deferredsFinished = 0;
        addResult = function(succeeded, result, count) {
          resultList[count] = [succeeded, result];
          deferredsFinished++;
          if (deferredsFinished === list.length) {
            self.resolve(resultList);
          }
          return void 0;
        };
        thenFunc = function(i) {
          return item.then(function(result) {
            if (fireOnOneCallback) {
              self.resolve([i, result]);
              return void 0;
            } else {
              addResult(true, result, i);
              return void 0;
            }
          }, function(error) {
            if (fireOnOneErrback) {
              self.reject(error);
            } else {
              addResult(false, error, i);
            }
            if (consumeErrors) {
              return null;
            }
            throw error;
            return void 0;
          });
        };
        for (i = _i = 0, _len = list.length; _i < _len; i = ++_i) {
          item = list[i];
          thenFunc(i);
        }
        return this;
      }
    });
  });

}).call(this);

//# sourceMappingURL=DeferredList.js.map
